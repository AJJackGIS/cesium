<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <meta
      name="description"
      content="Mars terrain visualized using 3D Tiles, tiled and hosted by Cesium ion, and shown with points of interest and additional data layers."
    />
    <meta name="cesium-sandcastle-labels" content="Showcases, ion Assets, 3D Tiles" />
    <title>Cesium Mars</title>
    <script type="text/javascript" src="../Sandcastle-header.js"></script>
    <script
      type="text/javascript"
      src="../../../Build/CesiumUnminified/Cesium.js"
      nomodule
    ></script>
    <script type="module" src="../load-cesium-es6.js"></script>
  </head>
  <body class="sandcastle-loading" data-sandcastle-bucket="bucket-requirejs.html">
    <style>
      @import url(../templates/bucket.css);
      #toolbar {
        background: rgba(42, 42, 42, 0.8);
        padding: 4px;
        border-radius: 4px;
      }
      #toolbar input {
        vertical-align: middle;
        padding-top: 2px;
        padding-bottom: 2px;
      }
      #toolbar .header {
        font-weight: bold;
      }
    </style>
    <div id="cesiumContainer" class="fullSize"></div>
    <div id="loadingOverlay"><h1>Loading...</h1></div>
    <div id="toolbar"></div>
    <script id="cesium_sandcastle_script">
      window.startup = async function (Cesium) {
        "use strict";
        //Sandcastle_Begin

        Cesium.Ellipsoid.default = Cesium.Ellipsoid.MARS;
        const viewer = new Cesium.Viewer("cesiumContainer", {
          terrainProvider: false,
          baseLayer: false,
          baseLayerPicker: false,
          geocoder: false,
          shadows: true,
          globe: false,
        });
        const scene = viewer.scene;
        const clock = viewer.clock;

        try {
          const tileset = await Cesium.Cesium3DTileset.fromIonAssetId(3644333, {
            enableCollision: true,
          });
          viewer.scene.primitives.add(tileset);
        } catch (error) {
          console.log(error);
        }

        const pointsOfInterest = [
          {
            text: "Olympus Mons",
            latitude: 18.65,
            longitude: 226.2,
          },
          {
            text: "Valles Marineris",
            latitude: -13.9,
            longitude: -59.2,
          },
          {
            text: "Gale Crater",
            latitude: -5.4,
            longitude: 137.8,
          },
          {
            text: "Schiaparelli Crater",
            latitude: -2.7,
            longitude: 16.7,
          },
          {
            text: "Sojourner Landing Site",
            latitude: 19.13,
            longitude: -33.22,
          },
          {
            text: "Spirit Landing Site",
            latitude: -14.5684,
            longitude: 175.472636,
          },
          {
            text: "Opportunity Landing Site",
            latitude: -1.9462,
            longitude: 354.4734,
          },
          {
            text: "Curiosity Landing Site",
            latitude: -4.589467,
            longitude: 137.441633,
          },
          {
            text: "Perseverance Landing Site",
            latitude: 18.44462715,
            longitude: 77.45088572,
          },
        ];

        const olympusMons = {
          destination: new Cesium.Cartesian3(-2549089.8672, -2720744.9822, 604987.2427),
          orientation: new Cesium.HeadingPitchRoll(6.2232, -0.7135, 0.0),
          easingFunction: Cesium.EasingFunction.LINEAR_NONE,
        };

        const vallesMarineris = {
          destination: new Cesium.Cartesian3(1962773.9022, -2712650.0794, -1111175.4271),
          orientation: new Cesium.HeadingPitchRoll(5.4566, -0.4563, 0.0),
          easingFunction: Cesium.EasingFunction.LINEAR_NONE,
        };

        const galeCrater = {
          destination: new Cesium.Cartesian3(-2791535.3207, 2189446.3646, -616541.9385),
          orientation: new Cesium.HeadingPitchRoll(5.5684, -0.636, 0.0),
          easingFunction: Cesium.EasingFunction.LINEAR_NONE,
        };

        const schiaparelliCrater = {
          destination: new Cesium.Cartesian3(3513269.5521, 664880.5211, -498902.5607),
          orientation: new Cesium.HeadingPitchRoll(0.8318, -0.5309, 0.0),
          easingFunction: Cesium.EasingFunction.LINEAR_NONE,
        };

        for (const poi of pointsOfInterest) {
          viewer.entities.add({
            position: Cesium.Cartesian3.fromDegrees(poi.longitude, poi.latitude),
            label: {
              text: poi.text,
              font: "18pt Verdana",
              outlineColor: Cesium.Color.DARKSLATEGREY,
              outlineWidth: 2,
              style: Cesium.LabelStyle.FILL_AND_OUTLINE,
              pixelOffset: new Cesium.Cartesian2(0, -22),
              scaleByDistance: new Cesium.NearFarScalar(1.5e2, 1.0, 1.5e7, 0.5),
              translucencyByDistance: new Cesium.NearFarScalar(2.5e7, 1.0, 4.0e7, 0.0),
              heightReference: Cesium.HeightReference.CLAMP_TO_GROUND,
              disableDepthTestDistance: new Cesium.CallbackProperty(() => {
                return Cesium.Cartesian3.magnitude(scene.camera.positionWC);
              }, false),
            },
            point: {
              pixelSize: 10,
              color: Cesium.Color.fromBytes(243, 242, 99),
              outlineColor: Cesium.Color.fromBytes(219, 218, 111),
              outlineWidth: 2,
              scaleByDistance: new Cesium.NearFarScalar(1.5e3, 1.0, 4.0e7, 0.1),
              heightReference: Cesium.HeightReference.CLAMP_TO_GROUND,
              disableDepthTestDistance: new Cesium.CallbackProperty(() => {
                return Cesium.Cartesian3.magnitude(scene.camera.positionWC);
              }, false),
            },
          });
        }

        // Define a callback property to dynamically change the width of polyline paths
        const widthCallbackProperty = new Cesium.CallbackProperty(function (time) {
          // Change width based on camera distance, via linear interpolation
          const cameraDistance = viewer.camera.positionCartographic.height;
          const minDistance = 0;
          const maxDistance = 1e5;
          const minWidth = 0;
          const maxWidth = 20;
          const t = Math.max(
            0,
            Math.min(1, (cameraDistance - minDistance) / (maxDistance - minDistance)),
          );
          const width = Cesium.Math.lerp(maxWidth, minWidth, t);
          return width;
        }, false);

        let curiosity, perseverance;
        try {
          const dataSource = await Cesium.CzmlDataSource.load(
            "../../SampleData/Mars.czml",
          );
          viewer.dataSources.add(dataSource);

          const setupRover = function (entityId, startSol, outRover) {
            outRover = dataSource.entities.getById(entityId);
            const positionProperty = outRover.position;
            outRover.orientation = new Cesium.VelocityOrientationProperty(
              positionProperty,
            );

            const julianDateToSol = createJulianDateToSolConverter(
              outRover.availability.start,
              startSol,
            );
            outRover.label.text = new Cesium.CallbackProperty(function (time) {
              return julianDateToSol(time);
            }, false);

            const roverPath = dataSource.entities.getById(`${entityId}Path`);
            roverPath.polyline.width = widthCallbackProperty;

            return outRover;
          };

          curiosity = setupRover("Curiosity", 3, curiosity);
          perseverance = setupRover("Perseverance", 13, perseverance);
        } catch (error) {
          console.log(`Error loading CZML: ${error}`);
        }

        clock.shouldAnimate = true;

        function createJulianDateToSolConverter(startJulianDate, startSol) {
          return function (julianDate) {
            const secondsPerSol = 24 * 60 * 60 + 39 * 60 + 35;
            const differenceInSeconds = Cesium.JulianDate.secondsDifference(
              julianDate,
              startJulianDate,
            );
            const solNumber = Math.floor(differenceInSeconds / secondsPerSol) + startSol;
            return `Sol ${solNumber}`;
          };
        }

        // Spin Mars on first load but disable the spinning upon any input
        const rotationSpeed = Cesium.Math.toRadians(0.1);
        const removeRotation = viewer.scene.postRender.addEventListener(
          function (scene, time) {
            viewer.scene.camera.rotateRight(rotationSpeed);
          },
        );

        const handler = new Cesium.ScreenSpaceEventHandler(viewer.scene.canvas);
        handler.setInputAction(
          () => removeRotation(),
          Cesium.ScreenSpaceEventType.LEFT_DOWN,
        );
        handler.setInputAction(
          () => removeRotation(),
          Cesium.ScreenSpaceEventType.RIGHT_DOWN,
        );
        handler.setInputAction(
          () => removeRotation(),
          Cesium.ScreenSpaceEventType.MIDDLE_DOWN,
        );
        handler.setInputAction(() => removeRotation(), Cesium.ScreenSpaceEventType.WHEEL);

        // Toolbar options to track various rovers / entities
        const flyToOrientation = new Cesium.HeadingPitchRoll(4.9791, -0.5294, 0.0);

        let activeEntity;
        let tracking = false;
        const onSelectRover = (rover) => {
          clock.multiplier = 100000;
          activeEntity = rover;
          removeRotation();
          clock.currentTime = rover.availability.start;
          const boundingSphere = new Cesium.BoundingSphere(
            rover.position.getValue(clock.currentTime),
            10000.0,
          );

          scene.camera.flyToBoundingSphere(boundingSphere, {
            offset: flyToOrientation,
            easingFunction: Cesium.EasingFunction.CUBIC_IN_OUT,
            complete: () => {
              if (tracking) {
                viewer.trackedEntity = activeEntity;
              }
            },
          });
        };

        const options1 = [
          {
            text: "Fly to rover...",
            onselect: () => {
              clock.multiplier = 1;
              activeEntity = undefined;
              scene.camera.flyHome(3.0);
            },
          },
          {
            text: "Curiosity",
            onselect: () => onSelectRover(curiosity),
          },
          {
            text: "Perseverance",
            onselect: () => onSelectRover(perseverance),
          },
        ];
        Sandcastle.addToolbarMenu(options1);

        const onSelectLandmark = (landmark) => {
          removeRotation();
          clock.multiplier = 1;
          activeEntity = undefined;
          scene.camera.flyTo(landmark);
        };

        const options2 = [
          {
            text: "Fly to landmark...",
            onselect: () => {
              removeRotation();
              scene.camera.flyHome(3.0);
            },
          },
          {
            text: "Olympus Mons",
            onselect: () => {
              onSelectLandmark(olympusMons);
            },
          },
          {
            text: "Valles Marineris",
            onselect: () => {
              onSelectLandmark(vallesMarineris);
            },
          },
          {
            text: "Gale Crater",
            onselect: () => {
              onSelectLandmark(galeCrater);
            },
          },
          {
            text: "Schiaparelli Crater",
            onselect: () => {
              onSelectLandmark(schiaparelliCrater);
            },
          },
        ];
        Sandcastle.addToolbarMenu(options2);

        Sandcastle.addToggleButton("Track Rover", false, function (tracked) {
          if (activeEntity && tracked) {
            viewer.trackedEntity = activeEntity;
            tracking = true;
          } else {
            viewer.trackedEntity = undefined;
            tracking = false;
          }
        });

        // Add a listener for when the home button is clicked
        viewer.homeButton.viewModel.command.beforeExecute.addEventListener(
          function (commandInfo) {
            clock.multiplier = 1;
            activeEntity = undefined;
          },
        );

        //Sandcastle_End
      };
      if (typeof Cesium !== "undefined") {
        window.startupCalled = true;
        window.startup(Cesium).catch((error) => {
          "use strict";
          console.error(error);
        });
        Sandcastle.finishedLoading();
      }
    </script>
  </body>
</html>
